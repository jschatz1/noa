%lex

%%

\/\/.*                            /* skip comment */
\/\*(.|\s)*\*\/                   /* skip comments */

\s+                               /* skip whitespace */

\b(pub|shh)\b                     return 'DEF'
\breturn\b                        return 'RETURN'
\bclass\b                         return 'CLASS'
\bstruct\b                        return 'STRUCT'
\bextends\b                       return 'EXTENDS'
\bif\b                            return 'IF'
\belse\b                          return 'ELSE'
\btrue\b                          return 'TRUE'
\bfalse\b                         return 'FALSE'
\bnull\b                          return 'NULL'

\d+                               return 'NUMBER'
\w+                               return 'IDENTIFIER'

[\=!]\=                           return 'EQUALITY_OPERATOR'
[><]\=?                           return 'RELATIONAL_OPERATOR'

\&\&                              return 'LOGICAL_AND'
\|\|                              return 'LOGICAL_OR'

\=                                return 'SIMPLE_ASSIGN'
[*/+\-]=                          return 'COMPLEX_ASSIGN'

[\+\-]                            return 'ADDITIVE_OPERATION'
[\*\/]                            return 'MULTIPLICATIVE_OPERATION'

/lex

%{

// Define AST node classes.
class Node {}

/* JS comments work here */
class Binary extends Node {}
class Primary extends Node {}

// Can define callbacks for parse events here,
// attaching to `yyparse` object.

yyparse.onParseBegin = (string) => {
  console.log('Parsing:', string);
};

yyparse.onParseEnd = (value) => {
  console.log('Parsed:', value);
};

function BinaryExpression(left, op, right) {
  return {
    type: 'BinaryExpression',
    op,
    left,
    right
  };
}

function Literal(namePrefix, value) {
  return {
    type: `${namePrefix}Literal`,
    value,
  }
}

function IfStatement(test, consequent, alternate) {
   return {
    type: 'IfStatement',
    test,
    consequent,
    alternate
   }
}

function LogicalExpression(left, op, right) {
  return {
    type: 'LogicalExpression',
    left,
    op,
    right
  }
}

%}

%nonassoc THEN
%nonassoc ELSE

%%

Program
  : StatementList
    {
      $$ = {
        type: 'Program',
        body: $1,
      }  
    }
  ;

StatementList
  : Statement
    { $$ = [$1] }
  | StatementList Statement
    { $1.push($2); $$ = $1 }
  ;

Statement
  : ExpressionStatement
  | EmptyStatement
  | BlockStatement
  | ClassDeclaration
  | FunctionDeclaration
  | ReturnStatement
  | IfStatement
  ;

IfStatement
  : IF '(' Expression ')' Statement %prec THEN
    { $$ = IfStatement($3, $5) }
  | IF '(' Expression ')' Statement ELSE Statement 
    { $$ = IfStatement($3, $5, $7) }
  ;

FunctionDeclaration
  : DEF Identifier '(' OptFormalParameterList ')' OptFunctionReturnType BlockStatement
    {
      $$ = {
        type: 'FunctionDeclaration',
        visibility: $1,
        name: $2,
        params: $4,
        returnType: $6,
        body: $7
      }
    }
  ;

ClassDeclaration
  : CLASS Identifier OptClassExtends Statement
    {
      $$ = {
        type: 'ClassDeclaration',
        id: $2,
        superClass: $3,
        body: $4,
      }
    }
  ;

OptClassExtends 
  : ClassExtends
  | /* empty */
    { $$ = null }
  ;

ClassExtends
  : EXTENDS Identifier
    { $$ = $2 }
  ;

Identifier
  : IDENTIFIER
    {
      $$ = {
        type: 'Identifier',
        value: $1,
      }
    }
  ;

TypeIdentifier
  : Identifier ':' Identifier
    {
      $$ = {
        type: 'TypeIdentifier',
        value: {
          name: $1, type: $3
        }
      } 
    }
  ;

OptFormalParameterList
  : FormalParameterList
  | /* empty */
    { $$ = [] }
  ;

OptFunctionReturnType
  : FormalFunctionReturnType
  | /* empty */
    { $$ = null }
  ;

FormalFunctionReturnType
  : ':' Identifier
  { $$ = { type: $2 } }
  ;

FormalParameterList
  : TypeIdentifier
    { $$ = [$1] }
  | FormalParameterList ',' TypeIdentifier
    { $1.push($3); $1 }
  ;

ExpressionStatement
  : Expression ';'
    { 
      $$ = {
        type: 'ExpressionStatement',
        expression: $1,
      }
    }
  ;

ReturnStatement
  : RETURN OptExpression ';'
    {
      $$ = {
        type: 'ReturnStatement',
        argument: $2,
      }
    }
  ;

OptExpression
  : Expression
  | /* empty */
    { $$ = null }
  ;

EmptyStatement
  : ';'
  {
    $$ = {
      type: 'EmptyStatement',
    }
  }
  ;

BlockStatement
  : '{' OptStatementList '}'
  {
    $$ = {
      type: 'BlockStatement',
      body: $2
    }
  }
  ;

OptStatementList
  : StatementList
  | /* empty */
    { $$ = [] }
  ;

Expression
  : AdditiveExpression
  ;

TypeAssignmentExpression
  : AssignmentExpression
  | LeftHandSideTypedExpression SIMPLE_ASSIGN AssignmentExpression
    {
      $$ = {
        type: 'TypeAssignmentExpression',
        left: $1,
        op: $2,
        right: $3
      }
    }
  ;

AssignmentExpression
  : LogicalORExpression
  | LeftHandSideExpression AssignmentOperator AssignmentExpression
    {
      $$ = {
        type: 'AssignmentExpression',
        left: $1,
        op: $2,
        right: $3
      }
    }
  ;

LeftHandSideTypedExpression
  : TypeIdentifier
  ;

LeftHandSideExpression
  : Identifier
  ;

AssignmentOperator
  : SIMPLE_ASSIGN
  | COMPLEX_ASSIGN
  ;

LogicalORExpression
  : LogicalANDExpression
  | LogicalORExpression LOGICAL_OR LogicalANDExpression
    { $$ = LogicalExpression($1, $2, $3) }
  ;

LogicalANDExpression
  : EqualityExpression
  | LogicalANDExpression LOGICAL_AND EqualityExpression
    { $$ = LogicalExpression($1, $2, $3) }
  ;

EqualityExpression
  : RelationalExpression
  | EqualityExpression EQUALITY_OPERATOR RelationalExpression
    { $$ = BinaryExpression($1, $2, $3) }
  ;

RelationalExpression
  : AdditiveExpression
  | RelationalExpression RELATIONAL_OPERATOR AdditiveExpression
    { $$ = BinaryExpression($1, $2, $3) }
  ;

AdditiveExpression
  : AdditiveExpression ADDITIVE_OPERATION MultiplicativeExpression
    {
      $$ = BinaryExpression($1, $2, $3)
    }
  | MultiplicativeExpression
  ;

MultiplicativeExpression
  : MultiplicativeExpression MULTIPLICATIVE_OPERATION PrimaryExpression
    {
      $$ = BinaryExpression($1, $2, $3)
    }
  | PrimaryExpression
  ;

PrimaryExpression
  : Literal
  | Identifier
  | ParenthesizedExpression
  ;

Literal
  : NumericLiteral
  | TrueLiteral
  | FalseLiteral
  | NullLiteral
  ;

TrueLiteral
  : TRUE { $$ = Literal('Boolean', true) }
  ;

FalseLiteral
  : FALSE { $$ = Literal('Boolean', false) }
  ;

NullLiteral
  : NULL { $$ = Literal('Numeric', null) }
  ;

NumericLiteral
  : NUMBER 
    {
      $$ = {
        type: 'NumericLiteral',
        value: Number($1)
      }
    }
  ;

ParenthesizedExpression
  : '(' Expression ')' { $$ = $2 }
  ;